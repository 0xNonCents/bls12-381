package bls

import (
	"crypto/rand"
	"errors"
	"flag"
	"math/big"
	"testing"
)

var fuz int

func TestMain(m *testing.M) {
	_fuz := flag.Int("fuzz", 10, "# of iterations")
	adx := flag.Bool("noadx", false, "to enfoce non adx arch")
	flag.Parse()
	forceNonADXArch = *adx
	fuz = *_fuz
	cfgArch()
	m.Run()
}

func randScalar(max *big.Int) *big.Int {
	a, err := rand.Int(rand.Reader, max)
	if err != nil {
		panic(errors.New(""))
	}
	return a
}

func randScalars(max *big.Int, size int) []*big.Int {
	var scalars []*big.Int
	for i := 0; i < size; i++ {
		a, err := rand.Int(rand.Reader, max)
		if err != nil {
			panic(errors.New(""))
		}
		scalars = append(scalars, a)
	}
	return scalars
}

func TestSwuMapperByIETFVectors(t *testing.T) {
	// all field elements are in montgomery form
	// G.9.2.  BLS12381G1_XMD:SHA-256_SSWU_NU_
	// https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-06#appendix-G.9.2
	g1Vectors := []struct {
		U *fe
		Q *PointG1
		P *PointG1
	}{
		{
			// u[0]: 0x0ccb6bda9b602ab82aae21c0291623e2f639648a6ada1c76d8ffb664130fd18d98a2cc6160624148827a9726678e7cd4
			U: &fe{11055906527226439532, 15381221316672119395, 808055961271427276, 14740302562114863533, 7658417636808732181, 1808897378552597641},
			Q: &PointG1{},
			P: &PointG1{
				fe{15113628385399762431, 4404687706597425931, 13863060742730879192, 16043877856210395921, 706161556023006056, 605875600377258218},
				fe{16163485871267757825, 16859800200815154795, 7304106007657581151, 2832467492533041022, 10488981490356020255, 481320876540394013},
				fe{8505329371266088957, 17002214543764226050, 6865905132761471162, 8632934651105793861, 6631298214892334189, 1582556514881692819}, // one
			},
		},
		{
			// u[0]: 08accd9a1bd4b75bb2e9f014ac354a198cbf607f0061d00a6286f5544cf4f9ecc1439e3194f570cbbc7b96d1a754f231
			U: &fe{12260652263603055737, 7275264387429045664, 7979508580028836149, 10336284957821343444, 17992074678572148462, 152935128437693850},
			Q: &PointG1{},
			P: &PointG1{
				fe{8537403074931846676, 5264597234595609371, 2461497008664195157, 11451664240898851506, 9685415210790331087, 863349221697556819},
				fe{14385002804058215472, 9546809736184875749, 1189602366381925116, 8933309970690236419, 4459900870844187871, 1760658779645784689},
				fe{8505329371266088957, 17002214543764226050, 6865905132761471162, 8632934651105793861, 6631298214892334189, 1582556514881692819}, // one
			},
		},
		{
			// 0a359cf072db3a39acf22f086d825fcf49d0daf241d98902342380fc5130b44e55de8f684f300bc11c44dee526413363
			U: &fe{1898960757059317784, 13787989208003688886, 11211580186960834984, 6370008762129431381, 14325130337946446726, 739186926502821726},
			Q: &PointG1{},
			P: &PointG1{
				fe{15906248760121499714, 17170297389246850569, 5479476633329698451, 8477388366197239813, 10855424814560332746, 531970162265396298},
				fe{10015889806444987957, 2401369241213157556, 66117835855544118, 5075211251286306471, 17588470859303156906, 1208821528686502249},
				fe{8505329371266088957, 17002214543764226050, 6865905132761471162, 8632934651105793861, 6631298214892334189, 1582556514881692819}, // one
			},
		},
		{
			// 181d09392c52f7740d5eaae52123c1dfa4808343261d8bdbaf19e7773e5cdfd989165cd9ecc795500e5da2437dde2093
			U: &fe{8833432824444571614, 2351827199444151866, 15462078084194367058, 15124831335740575068, 7821518470311712108, 966849045324012630},
			Q: &PointG1{},
			P: &PointG1{
				fe{4228754376586512035, 8569686174126306997, 18364615889791265488, 8255504103872168170, 26273213381453669, 33530525062727450},
				fe{4404581613571608037, 9421766288772888176, 4373912011692585009, 1033053174596494030, 13952852966087056568, 1684706875005186680},
				fe{8505329371266088957, 17002214543764226050, 6865905132761471162, 8632934651105793861, 6631298214892334189, 1582556514881692819}, // one
			},
		},
	}

	g1 := NewG1()
	mapper := newSwuMapper()
	for i, vector := range g1Vectors {
		actual, ok := mapper.toG1(vector.U)
		if !ok {
			t.Errorf("g1 vector#%d test failed", i)
		} else {
			if !g1.Equal(actual, vector.P) {
				t.Errorf("g1 vector#%d point is not equal to expected", i)
			}
		}

	}

	g2Vectors := []struct {
		U *fe2
		Q *PointG2
		P *PointG2
	}{
		{
			// u[0]: 09367e3b485dda3925e82cc458e5009051281d3e442e94f9ef9feec44ee26375d6dc904dc1aa1f831f2aebd7b437ad12
			U: &fe2{
				fe{16431081684992772022, 14159679474125455590, 17988520016754797042, 8935024614657511918, 15869015186916896171, 732095941057123996},
				fe{11561000447526874997, 15021656339745622710, 12441330760732930530, 17054292791175941726, 7297832093047633668, 333737753824539527},
			},
			Q: &PointG2{},
			P: &PointG2{
				fe2{
					fe{6604849728490158223, 13417705341870139816, 14619923645319859335, 18143186889339170092, 9574691932914161775, 1251876954965168522},
					fe{9050682939686461008, 15442846353150912367, 1752251852974285566, 10399420180359779239, 6368753314095755814, 435629167106495538},
				},
				fe2{
					fe{9655638565143489938, 3976467267586821792, 1231812612028726959, 9770551558559366293, 3316409279953996651, 802416595963779156},
					fe{636016545952207832, 4658663474134669448, 8607776637202742294, 7966416975852519488, 5062561060992753551, 292680112455240525},
				},
				fe2{
					fe{8505329371266088957, 17002214543764226050, 6865905132761471162, 8632934651105793861, 6631298214892334189, 1582556514881692819},
					fe{0, 0, 0, 0, 0, 0},
				},
			},
		},
	}
	g2 := NewG2(newFp2())
	for i, vector := range g2Vectors {
		actual, ok := mapper.toG2(vector.U)
		if !ok {
			t.Errorf("g2 vector#%d test failed", i)
		} else {
			if !g2.Equal(actual, vector.P) {
				t.Logf("actual: %s", toString(&actual[0][0]))
				t.Logf("expected: %s", toString(&vector.P[0][0]))
				t.Errorf("g2 vector#%d point is not equal to expected", i)
			}
		}

	}
}
